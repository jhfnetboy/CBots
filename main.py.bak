#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
主程序入口，启动所有服务
"""

# 首先导入补丁模块，修复Python 3.13中imghdr模块缺失的问题
try:
    import tweepy_patch
    print("已加载tweepy补丁，修复imghdr模块")
except Exception as e:
    print(f"加载tweepy补丁失败: {e}")

import logging
import asyncio
import threading
import os
import sys
from datetime import datetime, timedelta
from dotenv import load_dotenv
from telegram_core import TelegramCore
from telegram_api import TelegramAPI
from twitter_core import TwitterCore
from twitter_api import TwitterAPI
from web_service import WebService
from message_handlers import MessageHandlers
from telethon import events
import signal
import time

# 加载环境变量
load_dotenv()

def setup_logging():
    """设置日志配置"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('bot.log'),
            logging.StreamHandler(sys.stdout)
        ]
    )

logger = logging.getLogger(__name__)

class BotService:
    def __init__(self):
        self.telegram_core = TelegramCore()
        self.telegram_api = TelegramAPI(core=self.telegram_core)
        self.twitter_core = TwitterCore()
        self.twitter_api = TwitterAPI(core=self.twitter_core)
        self.message_handlers = None
        self.is_running = False
        self.last_message_time = None
        
    async def start(self):
        """Start the application"""
        try:
            # 启动 Telegram 核心服务
            if not await self.telegram_core.start():
                print("Failed to start Telegram core service")
                return False
                
            # 启动 Twitter 核心服务 (可选)
            # if self.twitter_core:
            #     if not await self.twitter_core.start():
            #         print("Failed to start Twitter core service")
            #         # Twitter 服务失败不影响整体运行
            #         print("Continuing without Twitter service")
            
            # 启动 API 服务
            if not await self.telegram_api.start():
                print("Failed to start Telegram API service")
                return False
                
            # if self.twitter_api:
            #     if not await self.twitter_api.start():
            #         print("Failed to start Twitter API service")
            #         # Twitter API 服务失败不影响整体运行
            #         print("Continuing without Twitter API service")
            
            # 更新状态
            self.is_running = True
            print("Application started successfully")
            return True
        except Exception as e:
            print(f"Error starting application: {e}")
            import traceback
            print(traceback.format_exc())
            return False
            
    async def stop(self):
        """停止服务"""
        try:
            if self.telegram_core.client:
                await self.telegram_core.client.disconnect()
            self.is_running = False
            logger.info("Bot service stopped")
            return True
        except Exception as e:
            logger.error(f"Error stopping bot service: {e}", exc_info=True)
            return False
            
    async def send_random_message(self):
        """发送随机消息"""
        try:
            if not self.is_running:
                return
                
            # 生成随机消息
            message = self.message_handlers.generate_random_message()
            
            # 发送消息
            await self.telegram_core.send_message(message)
            
            # 更新最后发送时间
            self.last_message_time = datetime.now()
            
            logger.info("Random message sent successfully")
            
        except Exception as e:
            logger.error(f"Error sending random message: {e}", exc_info=True)
            
    async def run(self):
        """运行服务"""
        try:
            while True:
                if not self.is_running:
                    # 尝试重启服务
                    if await self.start():
                        logger.info("Service restarted successfully")
                    else:
                        logger.error("Failed to restart service")
                        await asyncio.sleep(60)  # 等待1分钟后重试
                        continue
                        
                # 检查是否需要发送随机消息
                now = datetime.now()
                if (not self.last_message_time or 
                    now - self.last_message_time >= timedelta(hours=3)):
                    await self.send_random_message()
                    
                await asyncio.sleep(60)  # 每分钟检查一次
                
        except Exception as e:
            logger.error(f"Error in main loop: {e}", exc_info=True)
            self.is_running = False
            
def signal_handler(sig, frame):
    """
    处理程序退出信号
    """
    global running
    logger.info("收到退出信号，正在关闭所有服务...")
    running = False
    stop_all_services()
    sys.exit(0)

def start_telegram_service():
    """
    启动 Telegram 核心服务
    """
    try:
        logger.info("正在启动 Telegram 核心服务...")
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        telegram_core = TelegramCore()
        
        async def start():
            await telegram_core.start()
            logger.info("Telegram 核心服务启动成功")
            
            # 保持服务运行
            while running:
                await asyncio.sleep(1)
                
            # 关闭服务
            await telegram_core.stop()
            
        # 运行核心服务
        loop.run_until_complete(start())
        
    except Exception as e:
        logger.error(f"启动 Telegram 核心服务出错: {e}", exc_info=True)
        import traceback
        logger.error(traceback.format_exc())

def start_telegram_api_service():
    """
    启动 Telegram API 服务
    """
    try:
        logger.info("正在启动 Telegram API 服务...")
        telegram_api.start_api_server()
        logger.info("Telegram API 服务启动成功")
    except Exception as e:
        logger.error(f"启动 Telegram API 服务出错: {e}", exc_info=True)

def start_web_service():
    """
    启动 Web 服务
    """
    try:
        logger.info("正在启动 Web 服务...")
        
        # 在这里直接导入并初始化 Flask 应用
        # 不在这里直接运行，而是让 web_service 自己完成运行
        sys.argv = ['web_service.py']
        
        # 这个模块会自己处理启动 Flask 应用
        import web_service
        
        logger.info("Web 服务启动成功")
    except Exception as e:
        logger.error(f"启动 Web 服务出错: {e}", exc_info=True)

def start_twitter_service():
    """
    启动 Twitter 服务
    """
    try:
        logger.info("正在启动 Twitter 服务...")
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        twitter_core = TwitterCore()
        
        async def start():
            await twitter_core.start()
            logger.info("Twitter 服务启动成功")
            
            # 保持服务运行
            while running:
                await asyncio.sleep(1)
                
            # 关闭服务
            await twitter_core.stop()
            
        # 运行服务
        loop.run_until_complete(start())
        
    except Exception as e:
        logger.error(f"启动 Twitter 服务出错: {e}", exc_info=True)

def start_all_services():
    """
    启动所有服务
    """
    global telegram_thread, telegram_api_thread, web_service_thread, twitter_thread
    
    # 启动 Telegram 核心服务
    telegram_thread = threading.Thread(target=start_telegram_service, name="TelegramCoreThread")
    telegram_thread.daemon = True
    telegram_thread.start()
    
    # 等待 Telegram 核心服务启动成功
    time.sleep(2)
    
    # 启动 Telegram API 服务
    telegram_api_thread = threading.Thread(target=start_telegram_api_service, name="TelegramAPIThread")
    telegram_api_thread.daemon = True
    telegram_api_thread.start()
    
    # 等待 API 启动
    time.sleep(1)
    
    # 启动 Web 服务
    web_service_thread = threading.Thread(target=start_web_service, name="WebServiceThread")
    web_service_thread.daemon = True
    web_service_thread.start()
    
    # 启动 Twitter 服务
    twitter_thread = threading.Thread(target=start_twitter_service, name="TwitterThread")
    twitter_thread.daemon = True
    twitter_thread.start()
    
    logger.info("所有服务启动成功")

def stop_all_services():
    """
    停止所有服务
    """
    logger.info("正在停止所有服务...")
    
    # 这里不需要特别停止，因为我们使用的是 daemon 线程
    # 当主线程退出时，所有 daemon 线程会自动结束
    
    logger.info("所有服务已停止")

def main():
    """
    主函数
    """
    try:
        # 设置日志
        setup_logging()
        logger.info("Starting bot service...")
        
        # 设置信号处理函数
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
        
        # 创建主事件循环
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # 创建服务实例
        service = BotService()
        
        # 启动服务
        if not loop.run_until_complete(service.start()):
            logger.error("Failed to start bot service")
            return
            
        # 确保 Telegram 服务正在运行
        if not service.telegram_core.is_running:
            logger.error("Telegram core service is not running")
            return
            
        if not service.telegram_api.is_running:
            logger.error("Telegram API service is not running")
            return
            
        # 创建启动事件
        startup_event = threading.Event()
        
        # 启动 Web 服务
        web_service = WebService(service.telegram_api, service.twitter_api)
        web_thread = threading.Thread(
            target=lambda: web_service.run(startup_event)
        )
        web_thread.daemon = True
        web_thread.start()
        
        # 等待 Web 服务启动
        if not startup_event.wait(timeout=10):
            logger.error("Web service failed to start within timeout")
            return
            
        logger.info("All services started successfully")
        
        # 启动所有服务
        start_all_services()
        
        # 保持主线程运行
        while running:
            time.sleep(1)
            
    except KeyboardInterrupt:
        logger.info("收到键盘中断，正在退出...")
        stop_all_services()
    except Exception as e:
        logger.error(f"程序运行出错: {e}", exc_info=True)
        stop_all_services()

if __name__ == '__main__':
    main() 